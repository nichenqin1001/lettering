(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Lettering = factory());
}(this, (function () { 'use strict';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};









var taggedTemplateLiteral = function (strings, raw) {
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
};

var isFunction = function isFunction(obj) {
  return typeof obj == 'function' || false;
};

var EventEmitter = function () {
  function EventEmitter() {
    classCallCheck(this, EventEmitter);

    this.listener = new Map();
  }

  createClass(EventEmitter, [{
    key: 'addListener',
    value: function addListener(label, callback) {
      this.listener.has(label) || this.listener.set(label, []);
      this.listener.get(label).push(callback);
    }
  }, {
    key: 'removeListener',
    value: function removeListener(label, callback) {
      var listeners = this.listeners.get(label),
          index = void 0;

      if (listeners && listeners.length) {
        index = listeners.reduce(function (i, listener, index) {
          return isFunction(listener) && listener === callback ? i = index : i;
        }, -1);

        if (index > -1) {
          listeners.splice(index, 1);
          this.listeners.set(label, listeners);
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'emit',
    value: function emit(label) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var listeners = this.listener.get(label);

      if (listeners && listeners.length) {
        listeners.forEach(function (listener) {
          return listener.apply(undefined, args);
        });
        return true;
      }

      return false;
    }
  }]);
  return EventEmitter;
}();

var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
  window.setTimeout(callback, 1000 / 60);
};

// define cancelAnimationFrame function
var cAF = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;

var x = function x(p) {
  throw new Error("Missing Parameter: " + p);
};

var removeChild = function removeChild(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
};

var _templateObject = taggedTemplateLiteral(['el'], ['el']);

var defaultOptions = {
  fps: 15,
  autoStart: true,
  caretShow: true
};

/**
 * 
 * 
 * @class Lettering
 * @extends {EventEmitter}
 */

var Lettering = function (_EventEmitter) {
  inherits(Lettering, _EventEmitter);

  /**
   * Creates an instance of Lettering.
   * @param {HTMLElement} el required
   * @param {object} options configs
   * 
   * @memberof Lettering
   */
  function Lettering() {
    var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : x(_templateObject);
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
    classCallCheck(this, Lettering);

    // init type element
    var _this = possibleConstructorReturn(this, (Lettering.__proto__ || Object.getPrototypeOf(Lettering)).call(this));

    _this.el = typeof el === 'string' ? document.querySelector(el) : el;
    if (!!_this.el.children.length) console.warn('lettering:', 'HTMLCollection in the element will be ignored, only text inside will remain');
    _this.isInput = !!_this.el.placeholder;
    // the string will render into which element
    _this.output = _this.isInput ? 'placeholder' : 'textContent';
    // init options
    _this.options = _extends({}, defaultOptions, options);
    _this.caretColor = _this.options.caretColor || window.getComputedStyle(_this.el).getPropertyValue('color');
    // string inside the element
    _this.string = _this.isInput ? _this.el.placeholder : _this.el.innerText;

    var _index = void 0;
    Object.defineProperties(_this, {
      'stringIndex': {
        get: function get$$1() {
          return _index;
        },
        set: function set$$1(value) {
          if (value < 0) value = 0;
          if (value > this.maxStringIndex) value = this.maxStringIndex;
          _index = value;
        }
      }
    });

    _this.maxStringIndex = _this.string.length + 1;

    _this.stringIndex = 1;
    _this.isBackspace = false;
    _this.isAnitmating = false;
    // time stamp used to control frame speed, set to null initialize
    _this.lastTime = null;
    _this.requestId = null;

    _this._init();
    return _this;
  }

  createClass(Lettering, [{
    key: '_init',
    value: function _init() {
      removeChild(this.el);
      this.options.autoStart && this.typing();
    }
  }, {
    key: '_refresh',
    value: function _refresh() {
      this.maxStringIndex = this.string.length;
      return this;
    }
  }, {
    key: '_printChar',
    value: function _printChar() {
      var newString = this.string.substring(0, this.stringIndex);
      this.el[this.output] = newString;
      this.stringIndex++;
    }
  }, {
    key: '_removeChar',
    value: function _removeChar() {
      var newString = this.string.substring(0, this.stringIndex - 1);
      this.el[this.output] = newString;
      this.stringIndex--;
    }
  }, {
    key: '_animate',
    value: function _animate() {
      this.isAnitmating = true;
      // create new time stamp
      var now = Date.now();
      // calculate time delta
      var delta = now - this.lastTime;
      // the 1000 here means 1000ms;
      var shouldAnimate = delta > 1000 / this.options.fps;
      // main animation here
      if (shouldAnimate) {
        // print char into document
        this.isBackspace ? this._removeChar() : this._printChar();
        // update timestamp to calculate delta again in next animation loop
        this.lastTime = now;
      }

      if (this.stringIndex === this.maxStringIndex) {
        return this.stop().emit('afterTyping');
      }

      if (this.stringIndex === 0) {
        return this.stop().emit('afterBackspace');
      }

      if (this.isAnitmating) return this.requestId = rAF(this._animate.bind(this));
    }
  }, {
    key: 'updateContent',
    value: function updateContent(string) {
      var _this2 = this;

      var update = function update() {
        _this2.string = string;
        _this2._refresh().typing();
      };

      this.backspace().addListener('afterBackspace', update);
    }
  }, {
    key: 'typing',
    value: function typing() {
      this.isAnitmating = true;
      this.isBackspace = false;
      this.lastTime = Date.now();

      this._animate();
    }
  }, {
    key: 'backspace',
    value: function backspace() {
      this.isAnitmating = true;
      this.isBackspace = true;
      this.lastTime = Date.now();

      this._animate();
      return this;
    }
  }, {
    key: 'stop',
    value: function stop() {
      cAF(this.requestId);
      this.isAnitmating = false;
      this.isBackspace ? this.stringIndex++ : this.stringIndex--;
      return this;
    }
  }]);
  return Lettering;
}(EventEmitter);

return Lettering;

})));
