(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Lettering = factory());
}(this, (function () { 'use strict';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();



var taggedTemplateLiteral = function (strings, raw) {
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
};









var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var EventEmitter = function () {
  function EventEmitter() {
    classCallCheck(this, EventEmitter);

    this._events = {};
  }

  createClass(EventEmitter, [{
    key: "on",
    value: function on(event, fn) {
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;

      if (!this._events[event]) this._events[event] = [];
      this._events[event] = [].concat(toConsumableArray(this._events[event]), [[fn, context]]);
    }
  }, {
    key: "trigger",
    value: function trigger(event) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var events = this._events[event];

      if (!events) return;

      [].concat(toConsumableArray(events)).forEach(function (event) {
        console.log(args);

        var _event = slicedToArray(event, 2),
            fn = _event[0],
            context = _event[1];

        fn.apply(context, args);
      });
    }
  }]);
  return EventEmitter;
}();

var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
  window.setTimeout(callback, 1000 / 60);
};

// define cancelAnimationFrame function
var cAF = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;

var x = function x(p) {
  throw new Error("Missing Parameter: " + p);
};

var removeChild = function removeChild(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
};

var _templateObject = taggedTemplateLiteral(['el'], ['el']);

var defaultOptions = {
  fps: 15,
  autoStart: true,
  caretShow: true
};

/**
 * 
 * 
 * @class Lettering
 * @extends {EventEmitter}
 */

var Lettering = function (_EventEmitter) {
  inherits(Lettering, _EventEmitter);

  /**
   * Creates an instance of Lettering.
   * @param {HTMLElement} el required
   * @param {object} options configs
   * 
   * @memberof Lettering
   */
  function Lettering() {
    var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : x(_templateObject);
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
    classCallCheck(this, Lettering);

    // init type element
    var _this = possibleConstructorReturn(this, (Lettering.__proto__ || Object.getPrototypeOf(Lettering)).call(this));

    _this.el = typeof el === 'string' ? document.querySelector(el) : el;
    if (!!_this.el.children.length) console.warn('lettering:', 'HTMLCollection in the element will be ignored, only text inside will remain');
    _this.isInput = !!_this.el.placeholder;
    // init options
    _this.options = _extends({}, defaultOptions, options);
    _this.caretColor = _this.options.caretColor || window.getComputedStyle(_this.el).getPropertyValue('color');
    // string inside the element
    _this.string = _this.isInput ? _this.el.placeholder : _this.el.innerText;

    var _index = void 0;
    Object.defineProperties(_this, {
      'outputElement': { value: document.createElement('span') },
      'outputText': { value: document.createElement('span') },
      'outputCaret': { value: document.createElement('span') },
      // cause using String.substring function
      'maxStringIndex': { value: _this.string.length + 1 },
      'stringIndex': {
        get: function get$$1() {
          return _index;
        },
        set: function set$$1(value) {
          if (value < 0) value = 0;
          if (value > this.maxStringIndex) value = this.maxStringIndex;
          _index = value;
        }
      }
    });

    _this.stringIndex = 1;
    _this.isBackspace = false;
    _this.isAnitmating = false;
    // time stamp used to control frame speed, set to null initialize
    _this.lastTime = null;
    _this.requestId = null;

    _this._init();
    return _this;
  }

  createClass(Lettering, [{
    key: '_init',
    value: function _init() {
      removeChild(this.el);
      !this.isInput && this._createOutput()._cssOutputElement();
      this.options.autoStart && this.typing();
    }
  }, {
    key: '_createOutput',
    value: function _createOutput() {
      this.el.appendChild(this.outputElement);
      this.outputElement.appendChild(this.outputText);
      if (this.options.caretShow) {
        this.outputElement.appendChild(this.outputCaret);
        this._blink();
      }
      return this;
    }
  }, {
    key: '_cssOutputElement',
    value: function _cssOutputElement() {
      this.outputElement.style.position = 'relative';
      this.outputElement.style.display = this.outputText.style.display = this.outputCaret.style.display = 'inline-block';
      this.outputCaret.style.position = 'absolute';
      this.outputCaret.style.top = 0;
      this.outputCaret.style.bottom = 0;
      this.outputCaret.style.right = '-5px';
      this.outputCaret.style.width = '2px';
      this.outputCaret.style.backgroundColor = this.options.caretColor || this.caretColor;
      this.outputCaret.style.opacity = 1;
    }
  }, {
    key: '_printChar',
    value: function _printChar() {
      var newString = this.string.substring(0, this.stringIndex);
      this.isInput ? this.el.placeholder = newString : this.outputText.textContent = newString;
      this.stringIndex++;
    }
  }, {
    key: '_removeChar',
    value: function _removeChar() {
      var newString = this.string.substring(0, this.stringIndex - 1);
      this.isInput ? this.el.placeholder = newString : this.outputText.textContent = newString;
      this.stringIndex--;
    }
  }, {
    key: '_animate',
    value: function _animate() {
      this.isAnitmating = true;
      // create new time stamp
      var now = Date.now();
      // calculate time delta
      var delta = now - this.lastTime;
      // the 1000 here means 1000ms;
      var shouldAnimate = delta > 1000 / this.options.fps;
      // main animation here
      if (shouldAnimate) {
        // the caret always show when you are typing, right?
        this.outputCaret.style.opacity = 1;
        // print char into document
        this.isBackspace ? this._removeChar() : this._printChar();
        // update timestamp to calculate delta again in next animation loop
        this.lastTime = now;
      }
      if (this.stringIndex === this.maxStringIndex || this.stringIndex === 0) return this.stop().trigger('done', { string: this.string });
      if (this.isAnitmating) return this.requestId = rAF(this._animate.bind(this));
    }

    /**
     * caret blink animation
     * all the time stamp will wrapped inside the function
     * because the rate of blink animation is constant
     * @memberof Lettering
     */

  }, {
    key: '_blink',
    value: function _blink() {
      var _this2 = this;

      var lastTime = Date.now();

      var _blinkAnimate = function _blinkAnimate() {
        var now = Date.now();
        var delta = now - lastTime;
        var shouldBlink = delta > 1000 / 2;

        if (shouldBlink) {
          _this2.outputCaret.style.opacity--;
          if (_this2.outputCaret.style.opacity < 0) _this2.outputCaret.style.opacity = 1;
          lastTime = now;
        }

        rAF(_blinkAnimate.bind(_this2));
      };

      _blinkAnimate();
    }
  }, {
    key: 'typing',
    value: function typing() {
      this.isAnitmating = true;
      this.isBackspace = false;
      this.lastTime = Date.now();

      this._animate();
    }
  }, {
    key: 'backspace',
    value: function backspace() {
      this.isAnitmating = true;
      this.isBackspace = true;
      this.lastTime = Date.now();

      this._animate();
    }
  }, {
    key: 'stop',
    value: function stop() {
      cAF(this.requestId);
      this.isAnitmating = false;
      this.isBackspace ? this.stringIndex++ : this.stringIndex--;
      return this;
    }
  }]);
  return Lettering;
}(EventEmitter);

return Lettering;

})));
