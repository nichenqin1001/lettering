(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Lettering = factory());
}(this, (function () { 'use strict';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};









var taggedTemplateLiteral = function (strings, raw) {
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
};

var isFunction = function isFunction(obj) {
  return typeof obj == 'function' || false;
};

var EventEmitter = function () {
  function EventEmitter() {
    classCallCheck(this, EventEmitter);

    this.listener = new Map();
  }

  createClass(EventEmitter, [{
    key: 'addListener',
    value: function addListener(label, callback) {
      this.listener.has(label) || this.listener.set(label, []);
      this.listener.get(label).push(callback);
    }
  }, {
    key: 'once',
    value: function once(label, callback) {
      var _this = this;

      var fired = false;

      var magic = function magic() {
        _this.removeListener(label, callback);

        if (!fired) {
          fired = true;
          callback.apply(undefined, arguments);
        }
      };

      this.addListener(label, magic);
    }
  }, {
    key: 'removeListener',
    value: function removeListener(label, callback) {
      var listeners = this.listener.get(label);

      if (listeners) {
        this.listener.set(label, listeners.filter(function (listener) {
          return !(isFunction(listener) && listener === callback);
        }));
      }
    }
  }, {
    key: 'emit',
    value: function emit(label) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var listeners = this.listener.get(label);

      if (listeners && listeners.length) {
        listeners.forEach(function (listener) {
          return listener.apply(undefined, args);
        });
      }
    }
  }]);
  return EventEmitter;
}();

var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
  window.setTimeout(callback, 1000 / 60);
};

// define cancelAnimationFrame function
var cAF = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;

var throwDefaultError = function throwDefaultError(p) {
  throw new Error("Missing Parameter: " + p);
};

var removeChild = function removeChild(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
};

var _templateObject = taggedTemplateLiteral(['el'], ['el']);

var defaultOptions = {
  fps: 15,
  autoStart: true,
  caretShow: true,
  caretContent: '|'
};

/**
 * 
 * 
 * @class Lettering
 * @extends {EventEmitter}
 */

var Lettering = function (_EventEmitter) {
  inherits(Lettering, _EventEmitter);

  /**
   * Creates an instance of Lettering.
   * @param {HTMLElement} el required
   * @param {object} options configs
   * 
   * @memberof Lettering
   */
  function Lettering() {
    var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : throwDefaultError(_templateObject);
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
    classCallCheck(this, Lettering);

    // init type element
    var _this = possibleConstructorReturn(this, (Lettering.__proto__ || Object.getPrototypeOf(Lettering)).call(this));

    _this.el = typeof el === 'string' ? document.querySelector(el) : el;
    if (!!_this.el.children.length) console.warn('lettering:', 'HTMLCollection in the element will be ignored, only text inside will remain');
    // check if is input element
    _this.isInput = !!_this.el.placeholder;
    // string inside the element
    _this.string = _this.isInput ? _this.el.placeholder : _this.el.innerText;
    // the string will render into which element
    _this.target = _this.isInput ? 'placeholder' : 'textContent';

    _this.outputElement = _this.isInput ? _this.el : document.createElement('span');

    // init options
    _this.options = _extends({}, defaultOptions, options);

    _this.caretShow = _this.options.caretShow && !_this.isInput;

    _this.caretClassName = _this.options.caretClassName || 'lettering-caret';

    var _index = void 0;
    Object.defineProperties(_this, {
      'caretElement': { value: document.createElement('span') },
      'stringIndex': {
        get: function get$$1() {
          return _index;
        },
        set: function set$$1(value) {
          if (value < 0) value = 0;
          if (value > this.maxStringIndex) value = this.maxStringIndex;
          _index = value;
        }
      }
    });

    _this.maxStringIndex = _this.string.length + 1;

    _this.stringIndex = 1;
    _this.isBackspace = false;
    _this.isAnitmating = false;
    // time stamp used to control frame speed, set to null initialize
    _this.lastTime = null;
    _this.requestId = null;

    _this._init();
    return _this;
  }

  createClass(Lettering, [{
    key: '_init',
    value: function _init() {
      this._refresh(true);

      this.caretShow && this._createCaret()._cssCaret()._caretBlink();

      this.options.autoStart && this.typing();
    }
  }, {
    key: '_refresh',
    value: function _refresh(force) {
      if (force) {
        removeChild(this.el);
        this.isInput || this.el.appendChild(this.outputElement);
        this.stringIndex === 1;
      }
      this.maxStringIndex = this.string.length + 1;
      return this;
    }
  }, {
    key: '_createCaret',
    value: function _createCaret() {
      this.caret = document.createElement('span');
      this.el.appendChild(this.caret);
      return this;
    }
  }, {
    key: '_cssCaret',
    value: function _cssCaret() {
      this.caret.className = this.caretClassName;
      this.caret.innerHTML = this.options.caretContent;
      this.caret.style.opacity = 1;
      return this;
    }
  }, {
    key: '_caretBlink',
    value: function _caretBlink() {
      var _this2 = this;

      var lastTime = Date.now();

      var blink = function blink() {
        var now = Date.now();
        var delta = now - lastTime;
        var shouldBlink = delta > 1000 / 2;

        if (shouldBlink) {
          _this2.caret.style.opacity--;
          if (_this2.caret.style.opacity < 0) _this2.caret.style.opacity = 1;
          lastTime = now;
        }

        rAF(blink.bind(_this2));
      };

      blink();
    }
  }, {
    key: '_renderChar',
    value: function _renderChar() {
      var newString = this.string.substring(0, this.stringIndex);
      this.outputElement[this.target] = newString;
    }
  }, {
    key: '_printChar',
    value: function _printChar() {
      this._renderChar();
      this.stringIndex++;
    }
  }, {
    key: '_removeChar',
    value: function _removeChar() {
      this.stringIndex--;
      this._renderChar();
    }
  }, {
    key: '_animate',
    value: function _animate() {
      if (!this.isAnitmating) return;
      // create new time stamp
      var now = Date.now();
      // calculate time delta
      var delta = now - this.lastTime;
      // the 1000 here means 1000ms;
      var shouldAnimate = delta > 1000 / this.options.fps;
      // main animation here
      if (shouldAnimate) {
        this.caretShow && (this.caret.style.opacity = 1);
        // print char into document
        this.isBackspace ? this._removeChar() : this._printChar();
        // update timestamp to calculate delta again in next animation loop
        this.lastTime = now;
      }

      if (this.stringIndex === this.maxStringIndex) {
        return this._stop().emit('afterTyping');
      }

      if (this.stringIndex === 0) {
        return this._stop().emit('afterBackspace');
      }

      if (this.isAnitmating) {
        return this.requestId = rAF(this._animate.bind(this));
      }
    }
  }, {
    key: 'updateContent',
    value: function updateContent(string) {
      var _this3 = this;

      this.backspace().once('afterBackspace', function () {
        _this3.string = string;
        _this3._refresh().typing();
      });

      return this;
    }
  }, {
    key: 'typing',
    value: function typing() {
      this.isAnitmating = true;
      this.isBackspace = false;
      this.lastTime = Date.now();

      this._animate();

      return this;
    }
  }, {
    key: 'backspace',
    value: function backspace() {
      this.isAnitmating = true;
      this.isBackspace = true;
      this.lastTime = Date.now();

      this._animate();

      return this;
    }
  }, {
    key: '_stop',
    value: function _stop() {
      cAF(this.requestId);
      this.isAnitmating = false;
      this.isBackspace ? this.stringIndex++ : this.stringIndex--;
      return this;
    }
  }]);
  return Lettering;
}(EventEmitter);

return Lettering;

})));
